abstraction achieve 2 ways

1.interface 

->we are unable to create instance of interface but we can assign object of concreate class to interface reference
->interface contains abstract, default(default and normal methods both are different), static methods
->interface can able to implement any no of times.

2.abstract class

->we are unable to create instance of abstract class but we can assign object of concreate class to abstract class reference
->abstract class contains abstract, static, normal methods(default and normal methods both are different)
->class can able to extend only once that is also immediate concreate sub class




super class:- class through which sub class class derived is called super class

sub class:-class that is derived from another class is called sub class

NOTE:- in java,in the absence of any other explict super class, every class implicitly a subclass of object class




Nested class

1.static nested class

outer class static methods
-------------------------- 

ClassName.methodName();

static nested class(default, private, protected, public)
-------------------

OuterClass.NestedClass nestedObject=new OuterClass.NestedClass();

nestedObject.print();








2.non static nested class/inner class(inheritance in non static nested class/inner class)

->local inner class(instance block or any conditional block)

NOTE:- object creation at local inner class separately and parent class separately



->member inner class(direct class inside the parent class/member is nothing but direct class inside the parent class)


OuterClass outerClassObj=new OuterClass();

OuterClass.InnerClass innerClassObj=outerClassObj.new InnerClass();

innerClassObj.print()


->anonymous inner class(without extending class or without creating class we can able to provide implementation at time of object creation)






Stack Memory:-
------------

->store temporary variables and separate memory block for methods
->store primitive data types
->store reference of the heap objects
1.strong reference
2.weak reference
    
2.1.soft reference

->each thread has its own stack memory.
->variables within a SCOPE is only visible and as soon as any variable goes out of the SCOPE, it get deleted from the stack(in LIFO order)
->when stack memory goes full, its throws "java.lang.StackOverflowError"


NOTE:-

SCOPE or FRAME( local variable array, frame data, operand stack)


Heap Memory:-
-----------

->store objects
->there is no order of allocating the memory
->garbage collector is used to delete the unreferenced objects from the heap.
1.mark and sweep algorithm
2.types of GC:
->single GC(serial GC)
->parallel GC(default java 8)
->CMS(concurrent mark sweep)
->G1



->heap memory is shared with all the threads
->heap also contains the string pool
->when heap memory goes full, its throws "java.lang.OutofMemoryError"
->heap memory is further divided into:

1.Young generation(minor GC happens here)
->Eden
->Survivor(s0,s1)
2.old/tenured generation(major GC happens here)
3.permanent generation(before java 7) / metaspace










Test blocks used for storing json object in string format

Pattern matching for instanceof

We can able to create reference for object and interface

Record

Automatic -canonical constructor

Compact constructor

Local record can't declare with public, private, protected

Lombok is external dependency

Record is java feature, so it can restrict add setter method

Also provide accessor method nothing but getter method like name()


class loader
------------

Loading
-------

Bootstrap class loader---->java standard library( java.lang or java.util)--->JAVA_HOME/JRE/LIB----->JDK/JRE/LIB(rt.jar)

extension class loader---->java extension library( javax.* or javax.jakarta)--->JAVA_HOME/JRE/LIB/EXT----->JDK/JRE/LIB/EXT

application class loader--->java application specific classes loads from classpath (environment variables)


Linking
-------

verification(is byte code generated from valid compiler or not, is there any virus or not)

preparation(initialize with default values for static variables)

resolution(symbolic references replace with original references)

Initialization
--------------

static variables

static blocks


JVM Runtime Data Areas

method area:-
1.stores class-level data like method code, constants and metadata. this is where class definitions are kept after loading.

heap area:-
1.stores all objects and their associated instance variables.
2.the jvm allocated memory for object instances in this area during runtime.
3.all static variables allocated memory in heap area

stack area:-
1.each thread in java gets its own stack. it stores local variables, method calls and partial results for method execution.
2.every time a method is invoked, a stack frame is created to store the data for that specific call.

program counter(pc) register:-
1.each thread has its own PC register. this register keeps track of the address of the next instruction to be executed in the thread's method.

Native method stack:-
1.stores native code(written in languages like c or c++) that java programs can interact with.
2.for example, when java calls system-level operations that are outside the scope of the JVM, native methods are used.




execution engine

the execution engine is responsible for running the java code. it reads the bytecode and performs the necessary operations. the execution engine is made up of two key components:

1.Interpreter:

->the interpreter reads the bytecode line-by-line and executed it.
->pros: simple to implement.
->cons: slower execution because it executes each instruction individually.

2.JIT compiler(just-in-time compiler):

1.the JIT compiler compiles the bytecode into native machine code for faster execution.
2.it identifies frequent code paths(called hotspots)and converts them into optimized machine code. this helps reduce the time spent interpreting frequently used method.

Garbage collection(GC)

Garbage collection is a process by which the JVM automatically frees up memory by reclaiming memory used by objects that are no longer referenced.

->the garbage collector scans the heap and removes objects that are no longer needed, ensuring that the JVM doesn't run out of memory.

Handling Native code:-
sometimes, you may need to execute code that is not written in java(e.g.., c/c++). JVM allows this through the java native interface(JNI), which allows java to interact with native code written in languages like c or c++




JAR(Java archive):-group of .class files


WAR(Web archive):- group of xml, html, css, js, jsp, servlet etc

EAR(enterprise archive):- EJB,JMS along with jar and war files



path:- it is looking for binary files(jdk/bin)

classpath:- it is looking for bytecode files(.class files)



interface
---------
1.if we don't know anything about implementation just we have requirement specification then we should go for interface.
2.inside interface every method is always public and abstract whether we are declaring or not. hence interface is also considered as 100% pure abstract class.
3.we can't declare interface method with the following modifiers.

public--->private(private allowing on java 9), protected

abstract--->final, static(static allowing on java 8),default(default allowing on java 8), synchronized, native, strictfp

4.every variable present inside interface is always public, static and final whether we are declaring or not.

5.we can't declare interface variables with the following modifiers. private, protected, transient, volatile.

6.for interface variables compulsory we should perforn initialization at the time of declaration otherwise we will get compile time error.
7.inside interface we can't declare instance and static blocks otherwise we will get compile time error.

8.inside interface we can't declare constructors.








abstract class
--------------
1.if we are talking about implementation but not completely(partial implementation) then we should go for abstract class.
2.every method present in abstract class need not be public and abstract. in addition to abstract methods we can take concreate methods also.
3.there are no restrictions on abstract class method modifiers.
4.the variables present inside abstract class need not be public, static and final
5.there are no restrictions on abstract class variable modifiers.
6.for abstract class variables it is not required to perform initialization at the time of declaration.
7.inside abstract class we can declare instance and static blocks.
8.inside abstract class we can declare constructor, which will be executed at the time fo child object creation.





inversion of control


we are not control the object creation and life cycle of bean but someone creating and control of life cycle of bean



collection interface------->value 


map interface------->key, value pairs



HashSet--->HashMap

LinkedHashSet--->LinkedHashMap

TreeSet--->TreeMap



1.Load factor
2.Entry<K,V> interface
3.re-hashing
4.performance






Map<>

Entry<>





hash 

key 

value 

next





hashcode % current size of the hashmap





collision time(same bucket index insertion time only collision happening)

Note:-first insertion based on the hashcode but same hashcode for the 2 keys then use the equals method for the keys if key already exists or not



1.same key already exists then replace value for the key 

2.same key not exists then create the new node 


Insertion time

1.hashcode

2.equals():-it is used to check replace existing node or add new node


Retrieval time

1.hashcode

2.equals():- if multiple node are present in the bucket then check key is present or not




1.LoadFactor(0.75------>12)

2.Treefy Threashold



contract


1.if object1 == object2 then their hashcode should be same also

2.if 2 objects hashcode is same doesn't mean 2 objects are equal



Average---->O(1)

worst case---->O(n)

















singleton 

hashmap

java memory model

solid principles

How HashSet Works Internally in Java?


Most of us use HashSet to store unique values.
But inside, it works very closely with HashMap.
Hereâ€™s the simple version ğŸ‘‡

1ï¸âƒ£ HashSet internally uses a HashMap
HashSet is basically a wrapper around HashMap.
Everything you add in a HashSet becomes a key inside an internal HashMap.

private transient HashMap<E,Object> map;
private static final Object PRESENT = new Object();

The value stored in the HashMap is just a dummy object called PRESENT.


---

2ï¸âƒ£ When you call add(value)
HashSet actually does:

map.put(value, PRESENT);

So the full HashMap internal logic applies:
hashing â†’ bucket selection â†’ equals() â†’ collision handling, etc.


---

3ï¸âƒ£ How duplicates are handled
If you add the same element again:

HashMap checks the bucket using hashCode()

Then calls equals() to compare keys

Since the key already exists, HashMap does not replace it, because the value (PRESENT) is the same

HashSet simply ignores the duplicate

add() returns false

The set remains unchanged


â¡ï¸ Unlike HashMap, where the value gets replaced for duplicate keys.


---

4ï¸âƒ£ Collision handling
Same behavior as HashMap:

First a linked list inside the bucket

If a bucket grows to 8 or more elements (and capacity â‰¥ 64), it converts into a Red-Black Tree for faster lookup

If elements reduce later, it may convert back into a list



---

5ï¸âƒ£ Iteration
When you loop through a HashSet:

for (E e : set) { ... }

Youâ€™re actually iterating through the keys of the internal HashMap.


---

6ï¸âƒ£ Null handling
HashSet allows one null value, because HashMap allows one null key.
It is stored in bucket 0.


---

7ï¸âƒ£ Time complexity

Average insert / search / delete â†’ O(1)

Worst case â†’ O(log n) (tree), or O(n) (linked list)



---

ğŸ’¡ In short:

HashSet uses HashMap internally

Your element becomes the key

A dummy object becomes the value

Duplicates are ignored, not overwritten

All HashMap rules (hashing, buckets, collisions) apply underneath






HashMap-------->for comparision equals() used

IdentityHashMap-------->for comparision == reference operator used


HashSet and HashMap---------->default capacity 16(Load factor---->0.75)

HashTable------>default capacity 11(Load factor---->0.75)




If (bucket_length >= 8 AND table_capacity >= 64)
        â†’ Convert LinkedList to Red-Black Tree
Else
        â†’ Resize table (grow array)






If tree nodes in a bucket drop to â‰¤ 6, it converts back to a linked list.












