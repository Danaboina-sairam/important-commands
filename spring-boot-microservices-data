product-service:-getting details of product

order-service:-posting details of product

multiple instance of infrastructure microservices(API Gateway,Service discovery,Load balancer)

multiple instance of business microservices(Producr service , Order service)


NOTE :- 

1.multiple instaces are generating by  using Region and Availabilty zone only

2.client request also split by using DNS(AWS 53 Route , Azure traffic manager) and share to API Gateway

3.DNS also not a single point failure because in that also different DNS available

4.API Gateway very intelligent compare to Load balancer 

5.Load balancer after traffic distribute to different instance of microservice again inform to API Gateway

6.API Gateway--->Routing capability

7.Load balancer--->only distributing capability






server.port

allow parallel run


spring.application.name--------->it used in eureka website and restcall calling time(localhost:8080 is replaced by spring.application.name)


Service Discovery


Eureka Server 

Eureka Client(Load balancing implementing at client side)


Configuration class return-type and method-name used in service class return-type as Class name and method-name as reference variable name


spring.application.name replace hostname:port in while rest calling


Setup on Gateway(api call)
Add routes in application.yml
Use lb:// in route URI
Add spring-cloud-starter-gateway
Register gateway with Eureka


Setup on Client(rest call)
Add @LoadBalanced bean
Use http://<service-name>
Include spring-cloud-starter-loadbalancer
Register with Eureka


API Gateway

1. API Gateway also one of the client in Service discovery


ID----->microservice name

URI---->base url of api

predicate---->endpoint url of api



route are used for multiple microservice that's why used array index

predicate are used for multiple api endpoints that's why used array index


note:- eureka url calling by using api gateway




Circuit breaker(name and fallbackMethod attributes)

note:- 

1.name attribute value is after the instance property name whatever user provided name passing to that attribute value

note:- name value provided by getting property after the instance provided by user defined name (for all circuit breaker,retry,timeout same )

2.circuit breaker test by using server stop and start of another application

3.testing timeout scenario need to implement logger and thread concepts in downstream microservice(because of thread concept downstream system responding very slowly)



tracing(slueth and zipkin)--------------->[microservice name,trace id, span id]
-------

1.trace id same for all the components

2.span id specific for each component




microservice to microservice communication


pod---->side car proxies(Dataplane vs control plane)

1.service discovery

2.client side load balancer

3.circuit breaker

4.retry(retry only for 500 error series)

5.telemetry cability(Oberavability capabilities)

6.authorization

7.deployment stratagies(initially Microservice A----->90% , Microservice B----->10%) 


ISTIO

1.sidecar--->Envoy
2.Configuration Manager---->Galley
3.Traffic controller---->Pilot
4.Security Manager---->Citadel



HashMap:-

1.hash

2.key

3.value

4.node

hashcode(hashcode generate based on the key )

storing in hashmap(after hashcode generate now apply on that (hashcode%size of hashmap----------->now getting inserting place of hashmap)

collision:-collision is nothing but multiple time value replacing for same key

case 1:

2 objects same then hashcode same

case 2:

2 objects hashcode same then objects are not same sometimes


note 
----

1.object noting but key

2.every where hash code with object used(both are not independent)





Service we are going to build

Product service:-Create and view products,act as Catalog

Order service:- can order products

Inventory service:-can check if product is in stock or not

Notification service:-can send notifications,after order is placed

Order service ,inventory service,Notification service are going to interact with each other




Classes
-------

Dto,Entity(@AllArgsConstructor,@NoArgsConstructor,@Data)

Controller,Service(@RequiredArgsConstructor)

@Data == @Getter + @Setter + @ToString + @EqualsAndHashCode + @RequiredArgsConstructor

@AllArgsConstructor(For all)

@RequiredArgsConstructor(Specific final and nonNull)

@NoArgsConstructor(NONE)

postman hitting
---------------

by using Dto fields reference variable passing in postman

NOTE:- parent and child class not using class names but using there references of fields

Integration Tests
-----------------

1.Testcontainers fetching url from docker that's why using MongoDBContainer

2.while calling content() used to send data but that is accepting only string data.so,converting json to string format by using object mapper

SPRING BOOT PROJECT CONVENTION
------------------------------

1.Artifact name and Project name Hyphan used(Note:- Hyphans not reflected in package name,so use hyphans in Artifact name and Project name)


@PostConstruct vs @Bean CommandLineRunner
-----------------------------------------

@PostConstruct
--------------

1.Run logic after dependency injection(initialization logic)

2.Initializing resources, validating beans, calling setup methods

3.No access to command-line args

@Bean CommandLineRunner
-----------------------

1.Run logic after Spring Boot starts (application logic)

2.Bootstrapping data, triggering jobs, test inserts

3.Has access to String[] args



spring.jpa.hibernate.ddl-auto=create-drop


Note:-1.update 2.none(production use only none)




WebClient webClient;(whatever created in config class that is used in required class but access decrease from high to low)
-------------------

Microservice Communication(Called Response DTO also need to place at calling side)
--------------------------

Need to implement Global Exception Handler for order-service
------------------------------------------------------------



Service Discovery
-----------------

Eureka Server
-------------

1.dependency
------------
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

2.annotation
------------
@EnableEurekaServer

3.properties
------------

eureka.instance.hostname=localhost

eureka.client.register-with-eureka=false

eureka.client.fetch-registry=false

eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

spring.application.name=discovery-server



Eureka Client
-------------

1.dependency
------------

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

2.annotation
------------

@EnableEurekaClient

3.properties
------------

eureka.client.serviceUrl.defaultZone=http://eureka:password@localhost:8761/eureka

spring.application.name=product-service


STATUS OF SERVICE DISCOVERY
---------------------------

http://localhost:8761/

Multiple Servers
----------------

edit configuration and env variables

http://inventory-service/api/inventory

Types of client side load balancing
-----------------------------------

1.config(Service Discovery)
--------

@Bean
@LoadBalanced
public WebClient.Builder webClientBuilder() {
	return WebClient.builder();
}

2.URL(API GATEWAY)
-----

## Product Service Route
spring.cloud.gateway.routes[0].id=product-service
spring.cloud.gateway.routes[0].uri=lb://product-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/product


API GATEWAY(Request went on api gateway or not identify based on the port in local)--------->(base uri along with port)
-----------

1.dependency
------------

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

2.annotation
------------

@EnableDiscoveryClient

@EnableEurekaServer

3.properties
------------

spring.application.name=api-gateway
eureka.client.serviceUrl.defaultZone=http://eureka:password@localhost:8761/eureka
app.eureka-server=localhost

## Product Service Route
spring.cloud.gateway.routes[0].id=product-service
spring.cloud.gateway.routes[0].uri=lb://product-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/product

NOTE:- how multiple server in service discovery server mapping in api gateway

## Discover Server Route
spring.cloud.gateway.routes[2].id=discovery-server
spring.cloud.gateway.routes[2].uri=http://eureka:password@localhost:8761
spring.cloud.gateway.routes[2].predicates[0]=Path=/eureka/web
spring.cloud.gateway.routes[2].filters[0]=SetPath=/

NOTE:-  

1.change discovery server path after change route default path by using SetPath=/

2.single server lb not working that's why using again http in URI



## Discover Server Static Resources Route
spring.cloud.gateway.routes[3].id=discovery-server-static
spring.cloud.gateway.routes[3].uri=http://eureka:password@localhost:8761
spring.cloud.gateway.routes[3].predicates[0]=Path=/eureka/**

NOTE:-  

1.above after routing getting without static resource webpage but we need with static resouce page for that we are using Path=/eureka/**

2.single server lb not working that's why using again http in URI


NOTE
----

2.URI:- it is a base uri

3.predicates:- it is a endpoint uri


ORDER OF COMPONENTS
-------------------

1.API GATEWAY(Client side Load balancer) 2.SERVICE DISCOVERY(Client side Load balancer) 3.Load balancer(Client side custom load balancer)



MAVEN
-----

mvn clean      ----->  Deletes the /target directory (cleans previous build artifacts)

mvn validate   ----->  Validates the project structure and configuration (pom.xml)

mvn compile    ----->  .class files generated from .java files

mvn test       ----->  Unit tests are compiled and run (using JUnit/TestNG)

mvn package    ----->  .jar/.war file generated in target/

mvn verify     ----->  Runs integration tests, checks packaged artifact

mvn install    ----->  .jar placed into local repository (~/.m2)

mvn site       ----->  Generates project documentation (in target/site) using plugins like maven-site-plugin

mvn deploy     ----->  .jar pushed to remote Maven repository (like Nexus/Artifactory)


<project>
    <modelVersion>...</modelVersion>
    <groupId>...</groupId>
    <artifactId>...</artifactId>
    <version>...</version>
    <packaging>...</packaging>
    <name>...</name>
    <description>...</description>
    <url>...</url>
    <parent>...</parent>
    <modules>...</modules>
    <properties>...</properties>
    <dependencies>...</dependencies>
    <dependencyManagement>...</dependencyManagement>
    <build>...</build>
    <reporting>...</reporting>
    <profiles>...</profiles>
    <repositories>...</repositories>
    <pluginRepositories>...</pluginRepositories>
    <distributionManagement>...</distributionManagement>
    <scm>...</scm>
    <ciManagement>...</ciManagement>
    <issueManagement>...</issueManagement>
    <developers>...</developers>
    <contributors>...</contributors>
    <licenses>...</licenses>
    <organization>...</organization>
</project>




order-service(OrderPlacedEvent)

notification-service(OrderPlacedEvent)

removing duplication of class in between microservices using avro schema registry


dependencies of avro
--------------------

avro file serialize by using below dependency

<dependency>
  <groupId>io.confluent</groupId>
  <artifactId>kafka-avro-serializer</artifactId>
  <version>7.5.1</version> <!-- or match your Confluent Platform version -->
</dependency>

schema register by using below dependencies

<dependency>
    <groupId>io.confluent</groupId>
    <artifactId>kafka-schema-registry-client</artifactId>
    <version>7.5.1</version>
</dependency>

enable avro for application

<dependency>
  <groupId>org.apache.avro</groupId>
  <artifactId>avro</artifactId>
  <version>1.11.1</version> <!-- or latest -->
</dependency>

AVRO maven plugin
-----------------

1.need to specify source location--------->that is in src/main/resources/avro folder of application

2.need to specify destination location-----> that is in src/main/java folder of application

<plugin>
  <groupId>org.apache.avro</groupId>
  <artifactId>avro-maven-plugin</artifactId>
  <version>1.11.1</version>
  <executions>
    <execution>
      <phase>generate-sources</phase>
      <goals>
        <goal>schema</goal>
      </goals>
      <configuration>
        <sourceDirectory>${project.basedir}/src/main/avro</sourceDirectory>
        <outputDirectory>${project.basedir}/src/main/java</outputDirectory>
      </configuration>
    </execution>
  </executions>
</plugin>


properties
----------


key-------->StringSerializer

value------>JsonSerializer






Rate limiter->Bulk head->timeout->Circuit breaker->Retry 


Rate limiter
------------

fixed window rate limiter
-------------------------

1.limit(request)
2.window(time)

Adavantage
----------
1.specified request processing any time in window

disadvantage
------------
1.first window last second 5 request comming and next window first second comming 5 request comming that traffic is increasing


sliding log(accept request ,storing exact timestamp)
-----------

1.limit(request)
2.window(time)


disadvantage
------------

1.extra memory for storing time stamp
2.sliding log request proccess then need to clean timestamp


sliding window counter
----------------------

sliding window counter with sub window
--------------------------------------

1.window 
2.sub window

sliding window counter with weighted window
-------------------------------------------


combination of fixed window and sliding log





multi threading 

aop(this is used in scenarios rate limiter,bulk head,time limiter)

supplyAsync()----->submit the task to thread pool

completedFuture()------>not submit the task to thread pool(just wrap the response)


bulk head types
---------------

1.semaphore

2.thread pool

NOTE:- all resilience patterns applied for rest calls























